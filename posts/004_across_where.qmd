---
title: "Si usas dplyr, debes aprender a usar across y where"
description: "Aprende a usar las funciones across y where de dplyr para realizar operaciones en m√∫ltiples columnas de manera eficiente. Estas herramientas mejoran la manipulaci√≥n y el procesamiento de datos en R."
date: 2024-05-30
categories: ['Tutorial', 'dplyr','across','where']
lang: "es"
image: images/dplyr_across_blank.png
comments:
  utterances:
    repo: quarto-dev/quarto-docs
toc: true
code-line-numbers: true
code-copy: true
toc-location: left
format: html
editor_options: 
  chunk_output_type: console
execute: 
  freeze: true
author:
  - name: Carlos Aguero
    affiliation: Aprende Tidyverse
    affiliation-url: https://aprendetidyverse.com/
citation: true
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, dpi = 400, fig.width = 8, fig.height = 6)
```

Si trabajas con datos, hay dos situaciones comunes que seguro has tenido que resolver. La primera es seleccionar o filtrar tus datos considerando el tipo de datos de alguna variable. Por ejemplo, ACP o un clustering jer√°rquico, es necesario seleccionar solo las variables num√©ricas. La segunda situaci√≥n es cuando necesitas aplicar una funci√≥n a todas las columnas de tu tabla, como escalar todas las columnas aplicando la misma funci√≥n, por ejemplo, `scale`, a cada columna o a cada columna num√©rica.

Estos escenarios se vuelven f√°ciles de escribir y leer cuando utilizamos las funciones `across` y `where` de `dplyr`. Con `across`, puedes aplicar una funci√≥n a m√∫ltiples columnas simult√°neamente, y con `where`, puedes filtrar columnas bas√°ndote en condiciones espec√≠ficas, como su tipo de dato.

La mejor forma de explicar esto es usando ejemplos concretos. A continuaci√≥n, veamos una serie de casos y c√≥mo resolverlos con estas funciones.

Para estos ejemplos usaremos un dataset que me encanta, llamado pinguinos üêß. Se presenta como una alternativa al t√≠pico dataset iris, el cual, no s√© vos, pero al menos yo ya estoy un poco harto üíï. Originalmente presentado en el paquete [palmerpenguins](https://allisonhorst.github.io/palmerpenguins/) desarrollado por [Allison Horst](https://orcid.org/0000-0002-6047-5564), [Alison Hill](https://orcid.org/0000-0002-8082-1890) y [Kristen Gorman](https://orcid.org/0000-0002-0258-9264), y luego traducido al espa√±ol por el paquete [datos](https://cran.r-project.org/web/packages/datos/index.html), una hermosa contribuci√≥n de [Riva Quiroga](https://orcid.org/0000-0002-1147-4135), Edgar Ruiz, Mauricio Vargas, [Mauro Lepore](https://orcid.org/0000-0002-1986-7988), Rayna Harris, Daniela Vasquez y Joshua Kunst.

## Ejemplo 1: Seleccionar solamente las variables num√©ricas


```{r, message=FALSE, warning=FALSE}
library(tidyverse)
library(datos)
glimpse(pinguinos)
```

```{r}
x <- select(pinguinos, where(is.numeric))
glimpse(x)
```

Podemos, a la funci√≥n `where`, pasar cualquier funci√≥n que reciba un vector y retorne un `TRUE/FALSE`, lo cual es √∫til al combinarlo con las funciones que R ya nos provee para verificar tipos como `is.numeric`, `is.factor`, `is.character`, `is.logical`. O podr√≠amos, ¬øpor qu√© no?, escribir nuestras propias funciones cortas.

Por ejemplo, quiero las columnas que no contengan valores ausentes `NA`.

```{r}
select(pinguinos, where(\(x) all(!is.na(x))))
```

::: {.column-margin}
La forma abreviada `\(x) x + 1` se interpreta como `function(x) x + 1`. Puede ser √∫til para hacer que el c√≥digo que contiene expresiones de funciones simples sea m√°s legible.
:::

## Ejemplo 2: Escalar todas las variables num√©ricas

En otro escenario, lo normal ser√≠a crear primero una tabla con todas las variables num√©ricas y escalarlas, ya que la funci√≥n `scale` no soporta variables no num√©ricas. En este caso, podemos hacer que la funci√≥n `scale` se aplique solamente a las variables num√©ricas, dejando las dem√°s intactas.

```{r}
pinguinos |> 
  mutate(
    across(
      where(is.numeric),
      \(x) as.vector(scale(x))
    )
  )
```

## Ejemplo 3: Resumir todas la variables num√©ricas calculando la media

Otro caso muy com√∫n es querer aplicar un resumen a m√∫ltiples columnas. Cuando tenemos muchas columnas o estas pueden, por la naturaleza de nuestros datos, cambiar de nombre con frecuencia, podemos implementar una soluci√≥n m√°s gen√©rica que calcule la media para cada variable num√©rica sin depender del nombre de las variables.

```{r}
pinguinos |> 
  summarise(
  across(
    where(is.numeric), # solamente num√©ricas
    \(x) mean(x, na.rm = TRUE)) # calculamos la media para cada variable
  )
```

## Ejemplo 4: Resumir todas la variables num√©ricas calculando la media y la mediana

Ahora bien, si queremos aplicar m√°s de una funci√≥n de resumen, en lugar de pasar una sola funci√≥n como par√°metro, podemos pasar una lista con varias funciones. A cada una de las columnas indicadas por `where` se le aplicar√°n todas las funciones de la lista.

```{r}
x <- pinguinos |> 
  summarise(
    across(
      .cols = where(is.numeric),
      .fns = list(
              media = \(x) mean(x, na.rm = TRUE),
              mediana = \(x) median(x, na.rm = TRUE)
            )
    )
  )

glimpse(x)
```


::: {.column-margin}
Para evitar confusiones, es posible que indiquemos los nombres de los par√°metros de la funci√≥n `across`. El primer par√°metro es `.cols`, que contiene el where o las variables de la tabla que se van a utilizar, y el segundo par√°metro es `.funs`, que puede ser una funci√≥n o una lista de las funciones que se van a aplicar a cada una de las columnas.
:::


## Ejemplos 5 Convertir todas las variables de tipo character en Factor

Aunque para muchas operaciones podemos trabajar con textos sin problema, la mayor√≠a de los modelos necesitan variables de tipo factor en lugar de textos para funcionar correctamente. En este caso, por ejemplo, si queremos convertir todos los textos en factores, podemos hacerlo de la siguiente manera.

```{r}
x <- pinguinos |> 
  mutate(
    across(
      where(is.character),
      as.factor
    )
  )

glimpse(x)
```


Estas funciones nos ofrecen muchas ventajas. Para m√≠, la principal es poder dise√±ar scripts que dependen m√°s de los tipos que de los nombres. No tener que conocer la cantidad ni el nombre de las variables para poder realizar operaciones se vuelve mucho m√°s pr√°ctico. Como resultado, tenemos un c√≥digo m√°s sencillo de leer y f√°cil de mantener en el tiempo, ya que es posible que requiera menos cambios que otras alternativas.

::: {.callout-warning}
## Importante üö®

üöÄ¬°Atenci√≥n a todos los aspirantes a cient√≠ficos de datos! üöÄ

¬øQuieres aprender de la mano de un instructor experto y certificado por RStudio? ¬°Esta es tu oportunidad!

Este pr√≥ximo **s√°bado 3 de agosto a las 10:00 a.m. (hora Costa Rica)**, iniciaremos nuestro curso exclusivo: "[Fundamentos de R y RStudio](https://aprendetidyverse.com/courses/fundamentos_R.html)".

Imagina ser guiado paso a paso por un profesional que no solo domina R y RStudio, sino que tambi√©n sabe c√≥mo ense√±arte a dominar estas herramientas de manera efectiva.

üîç ¬øPor qu√© deber√≠as unirte? üîç

+ **Aprendizaje personalizado:** Obt√©n atenci√≥n individualizada para asegurar tu √©xito.

+ **Seguimiento semanal:** Recibe orientaci√≥n semanal para aplicar lo que se ve en clase a tu √°rea de expertise.

+ **Horario flexible:** Atiendo tus dudas en horarios que se adaptan a tu vida; puedes recibir asesor√≠a en horario nocturno o fines de semana.


No dejes pasar esta oportunidad de transformar tu carrera y adquirir habilidades que est√°n en alta demanda.

Inscr√≠bete ahora y da el primer paso hacia tu futuro en la ciencia de datos.

[üìñ ¬°Quiero saber m√°s!](https://aprendetidyverse.com/courses/fundamentos_R.html)

:::
